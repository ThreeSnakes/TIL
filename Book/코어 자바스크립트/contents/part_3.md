# 코어 자바스크립트

## 날짜: 2020.05.28

## Part_3. this

## 목차

- [this](#this)
- [상황에 따라 달라지는 this](#상황에-따라-달라지는-this)
  - [전역 공간에서의 this](#전역-공간에서의-this)
  - [메서드로서 호출할 떄 그 메서드 내부에서의 this](#메서드로서-호출할-떄-그-메서드-내부에서의-this)
- [명시적으로 this를 바인딩하는 방법](#명시적으로-this를-바인딩하는-방법)

### this

- 대부분의 객체지향 언에서 this는 클래스로 생성한 인스턴스 객체를 의미한다. 하지만 자바스크립트에서의 this는 어디서든지 자유롭게 사용할 수 있다.
- this를 어디에서 사용하느냐에 따라서 this가 가라키는 대상이 달라진다.
- **함수와 객체(메서드)의 구분이 느슨한 자바스크립트에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능이다.**

### 상황에 따라 달라지는 this

- this는 기본적으로 실행 컨텍스트가 생성될때 결정되는데, 실행 컨텍스트는 함수를 호출할 때 생성된다. 즉, **this는 함수를 호출할 때 결정된다.**
- 함수를 어디서 호출하느냐에 따라 this의 바인딩 되는 값이 달라진다.

#### 전역 공간에서의 this

- 전역 공간에서 this는 전역 객체를 가리킨다. 브라우저에서는 window, Node.js 에서는 global 객체를 가린키다.
- **전역 공간에서 변수를 선언하면 이는 전역객체(window, global)의 property로 항당**되는데, 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작한다. 정확히 말하면 **전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다.**
- 전역 변수를 선언할때 처음부터 전역객체의 프로퍼티로 할당하면 삭제가 되지만, 전역 변수로 선언하는 경우에는 delete 연산으로 삭제가 되지 않는다.
  
  ``` js
  var a = 1;
  window.b = 1;

  delete a;
  delete window.b;

  console.log(a);         // 1
  console.log(window.b);  // undefined
  ```

#### 메서드로서 호출할 떄 그 메서드 내부에서의 this

- 일단 함수와 메서드의 차이를 이해해야 한다. 둘다 프로그래머가 정의한 동작을 수행하는 코드지만, 함수는 독립적으로 수행할 수 있지만, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다.
- 메서드는 **"객체에 프로퍼티에 할당된 함수"**라는 말은 반은 맞고 반은 틀리다. 함수를 객체의 프로퍼티로 할당한다고 무조건 메서드가 되는 것이 아니라 **객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않은 경우에는 함수로 동작한다.**
  - 함수로서 호출과 메서드로서의 호출은 함수 앞에 점(.)이 있는지를 보거나 함수를 호출 할때 앞에 객체가 명시되어 있는지를 보면 쉽게 확인할 수 있다.

  ``` js
  // 함수로서의 호출, 메서드로서의 호출 비교
  var test = function () {
    console.log("CALL TEST()");
    console.log(this)
  };
  test() // 함수로서 호출, this에 전역객체 호출

  var object = {
    a: 1,
    test: test
  };
  object.test();  // 메서드로서 호출, this에 object가 들어간다.
  ```

- **메서드 내부에서 호출**을 할 경우 **this**에는 **호출한 주체에 대한 정보**가 담긴다.
- 즉 **함수 앞에 명시되어 있는 객체가 곧 this가 된다.**

#### 함수로서 호출할 때 그 함수 내부에서의 this

- **어떤 함수를 함수로서 호출할 경우에는 this가 지정되지 않는다. 다만 this가 지정되지 않으면 this는 전역 객체를 바라보게 된다.**

### 명시적으로 this를 바인딩하는 방법