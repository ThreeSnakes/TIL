# 함수형 자바스크립트

## 날짜: 2019.12.18 ~

## Part_1. 함수형으로 사고하기

### 목차

1. [함수형 길들이기](#함수형-길들이기)

#### 함수형 길들이기

- 자바스크립트는 언어 내부에 상태를 적절히 관리할 장치가 마땅치 않다. ( 자바스크립트 동적 언어이다 보니 상태가 계속 변경 될 수 있음을 말하는 것인지 헷갈린다? )
- 함수형 프로그래밍(FP: Functional Programming)은 애플리케이션을 작성할 때 확장성, 모듈화, 재사용성, 테스트 용이성 등 많은 도움을 줄 수 있다.
- FP는 프레임워크나 도구가 아니다. 지금까지 객체지향으로 개발해왔던 사고와 근본적으로 다르며 FP를 사용하기 위해서는 사고를 전환해야 한다.
- FP의 진정한 목적은 어떤 결과를 만드는 함수를 적용하는 그런 단순한 차원이 아니다. 진짜 목표는 **애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상(abstract)하는 것이다.**
- 함수형 프로그램을 이해하려면, 다음 기본 개념을 이해해야 한다
  - **선언적 프로그래밍**
    - FP는 큰 틀에서 선언적 프로그래밍 패러다임에 속한다
    - 명령형 프로그램은 어떤 결과를 내기 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 죽 늘어놓은 순차 열에 불과하다. 이와 달리 선언적 프로그래밍은 서술부와 평가부를 분리하여, 제어 흐름이나 상태 변화를 특정하지 않고도 프로그램 로직이 무엇인지를 **표현식**으로 나타낸다
    - FP를 하기 위한 첫 번째 작업은 명령형으로 작성된 코드를 함수로 추상화하는 것이다
    - FP는 **무상태성**과 **불변성**은 지향한다
    - FP는 부수효과와 상태 변이를 일으키지 않는 **순수함수**를 써야 한다.
  - **순수 함수**
    - 기본적으로 FP는 순수함수로 구성된 불변 프로그램을 구축을 전제로 한다. 그럼 순수 함수는 무엇일까?
      - 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 동작하는 함수
      - 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는 함수
      - 예시 코드

        ``` js
        // 아래 함수는 함수 밖에 있는 외부 스코프의 변수를 읽고 수정한다.
        // 이 함수는 부수효과를 동반하기 때문에 순수함수가 아니다.
        var counter = 0
        function increment() {
          return ++counter;
        }

        // 아래 함수는 호출 될때마다 값이 달라진다.
        // 이는 순수함수가 아니다
        function getDate() {
          return new Date();
        }

        // 억지로 만들어낸 예제이다. 말이 안되긴 한다;;
        // 아래는 매개변수로 들어온 값을 변경해버린다. 이것도 순수함수가 아니다.
        function add(x, y) {
          x += y
          return x;
        }
        ```

    - FP는 모든 상태 변이를 근절을 주장하는 것은 아니다. 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다
    - **함수가 일관된 반환 값을 보장하도록 해서 전체 함수 결과를 예측 가능한 방향으로 유도하는 것이 목표이다.**
  - **참조 투명성**
    - 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 **참조 투명한 함수**라 한다.
    - 참조 투명함 함수 사용 시 이점
      - 테스트가 쉬워진다
      - 전체 로직을 파악하는 것도 쉬워진다.
      - 리팩토링/치환 등의 작업을 쉽게 할 수 있다.
    - 참조 투명한 함수를 작성할 때는 객체를 변이하지 않는 것이 중요하다.
  - **불변성**
    - 불변 데이터는 한번 생성된 후 바뀌지 않는다. 하지만 array나 Object 등의 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 수 있다.
- 결국 **FP**는 **외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것을 말한다.**
- 함수를 순수 연산의 관점에서 데이터를 절대 변경하지 않는 고정된 작업 단위로 바라본다면 버그는 줄어들게 돼있다
- FP로 개발을 하면 무엇이 좋아질까? 일반적으로 FP로 개발을 하게 된다면 다음처럼 작업하게 될 것이다.
  - **간단한 함수로 작업을 분해한다.**
    - 함수를 작게 분해할 경우 작업 단위는 바로 함수 자신이 된다.
    - FP에서 모듈화는 단일성의 원리와 밀접한 관련이 있다. 함수는 저마다 한 가지 목표만 바라봐야 한다는 것이다
    - 이런 작은 함수 여러 개를 실행해서 하나의 큰 작업을 진행하는 것이다. 이때 **합성** 기법 개념이 나온다.
      - 설명

      ``` text
      두 함수 f, g가 있을때 이 두개를 함성하면 수학적으로 다음과 같아진다. 'f 합성 g' 라고 있는다.
      f * g = f(g(x))
      ```

      - 예시

      ``` js
      // 위에 함성을 함수로 구현한 것이 합성 함수이다.
      var run = function(f, g) {
        return function(x) {
          return f(g(x));
        };
      };

      const multiplier = (x) => {
        return x * x;
      };

      const plus1 = (x) => {
        return x + 1;
      }

      // run에 함수 2개를 넣으면 함수가 리턴된다. 이 함수를 실행시켜야 합성 되는 것이다.
      const test = run(multiplier, plus1);
      // 위 코드는 결국 multiplier(plus1(x))가 된다.
      console.log(test(10));  // 121
      ```

      - 위 코드의 run처럼 다른 함수를 인수로 받는 함수를 **고계함수**라 한다.
      - lodash에도 위 run과 같은 동작을 하는 코드가 있다. 바로 _.flow, _.flowRight라는 코드인데 나중에 살펴보자.
  - **흐름 체인으로 데이터를 처리한다.**
    - **체인**은 같은 객체를 반환하는 순차적인 함수 호출이다.
    - 체인도 합성처럼 코드를 간결 명료하게 작성할 수 있다.
    - 함수 체인은 필요한 시점까지 실행을 미루는 **느긋한 평가(lazy evaluation)**을 수행한다.
      - 예시

      ``` js
      // lodash에서 chain을 사용하면 value()를 호출해야지 값을 얻을 수 있다.
      // 즉 value()를 호출 하지 않는다면 일련의 코드를 전부 실행하지 않는 다는 것이다.
      _.chain(list)
       .filter(item => item.price > 1000)
       .value();
      ```

  - **리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.**
    - **리액티브 패러다임이 무엇인지 조사가 필요해 보인다. 이해를 잘 못 하겠다...**
    - 리액티브 패러다임의 가장 큰 장점은, 더 높은 수준으로 코드를 추상하며 비동기, 이벤트 기반 프로그램을 설정하느라 반복되는 판박이 코드를 아예 잊고 비즈니스 로직에만 전념할 수 있게 해준다는 것이다.
    - 리액티브 패러다임은 옵저버블(opservable)이라는 아주 중요한 장치를 매개로 움직인다.

- **정리**
  - 순수 함수를 사용한 코드는 전역 상태를 바꾸거나 깨뜨릴 일이 전혀 없음므로 테스트, 유지보수가 더욱 더 쉬운 코드를 개발할 수 있게 해준다.
  - FP는 코드를 선언적으로 작성하므로 헤아리기 쉽고 전체 애플리케이션의 가독성이 향상된다. 또 함수와 람다 표현식으로 보다 깔끔하게 코딩할 수 있다.
  - 컬렉션 데이터는 map, reduce를 이용하면 함수 체인으로 연결하여 매끄럽게 처리 할 수 있다.
  - FP는 함수를 기본적인 구성 요소로 취급한다. 이는 일급/고계함수 개념에 기반을 두며 코드의 모듈성, 재사용성을 높여준다.
  - 리액티브/함수형 프로그램을 융합하면 이벤트 기반 프로그램 특유의 복잡성을 줄일 수 있다.
