# 함수형 자바스크립트

## 날짜: 2020.02.01 ~

## Part_2. 함수형으로 전환하기

## 목차

- [자료구조는 적게, 일은 더 많이](#자료구조는-적게-일은-더-많이)
  - [애플리케이션 제어 흐름](#애플리케이션-제어-흐름)
  - [메서드 체이닝](#메서드-체이닝)
  - [함수 체이닝](#함수-체이닝)
    - [람다 표현식](#람다-표현식)
    - [_.map](#_map)
    - [_.reduce](#_reduce)
    - [_.filter](#_filter)
    - [기타 함수](#기타-함수)
  - [코드 헤아리기](#코드-헤아리기)
    - [선언적 코드와 느긋한 함수 체인](#선언적-코드와-느긋한-함수-체인)
    - [_.chain](#_chain)
    - [_.mixin](#_mixin)

#### 자료구조는 적게, 일은 더 많이

- map, reduce, filter에 대해서 알아본다.
- lodash를 사용하는 법을 알아본다.
- 재귀함수에 대해서 알아본다.

##### 애플리케이션 제어 흐름

- 프로그램이 정답에 이르기까지 거치는 경로를 `제어 흐름(Contr flow)`이라 한다.
- FP는 독립접인 블랙박스 연산들이 단순하고, 최소한의 제어 구조를 통해 추상화시킨 후 이를 연결한다.
- FP는 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급한다.

``` js
// [ Func A ] --> [ Func B ] --> [ Func C ] --> [ Func D ]
// -------------------- 프로그램 실행 ----------------------

// 이를 코드화 시키면 다음처럼 표현 할 수 있다.
FuncA().FuncB().FuncC().FuncD();

// 다만 위코드 처럼 점으로 연결시키려면 
// 메서드가 모두 포함된 객체가 있어야 한다.
```

##### 메서드 체이닝

- `메서드 체이닝(method chaining)`은 여러 메서드를 단일 구문으로 호출하는 OOP 패턴이다.
- 메서드가 모두 동일한 객체에 속해 있으면 메서드 흘리기라고도 하는데 이는 객체지향 프로그램에서 불변 객체에 많이 사용하는 패턴이지만 FP에도 유용하다.

``` js
// Method chaining 예시
'hello World'.substring(0, 5).toUpperCase() + ' FP '; // HELLO FP

// FP 형태로 변형
concat(toUpperCase(subString('hello Work', 0, 5)), ' FP');
```

- 함수형 교리(불변객체, 부수효과X)를 모두 따르지만 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝보다는 이해하기 어렵다. 안쪽부터 하나씩 함수를 까봐야 하기 때문이다. 그렇다면 함수를 체이닝 하는 방법은 없는걸까? 이 방법에 대해서 알아보자.

##### 함수 체이닝

- 객체지향 프로그램은 주로 상속을 통해 코드를 재사용한다. EX -> 자바에서 List 인터페이스를 용도에 맞춰서 달리 구현한 ArrayList, LinkedList 등등이 있다. 이들은 모두 한 부모에서 출발하여 나름대로 특수한 기능을 덧붙인 클래스이다. 그래서 메서드 체이닝을 사용할 수 있다.
- 하지만 FP는 방법이 조금 다른데, **자료구조(클래스?)를 새로 만들어 어떤 요건을 충족시키는게 아니고, 배열 등의 흔한 자료구조를 이용해 다수의 굵게 나뉜 고계 연산을 적용한다.**
  - 작업을 수행하기 위해 무슨 일을 해야 하는지 기술된 함수를 인수로 받는다.
  - 임시 변수의 값을 계속 바꾸면서 부수효과를 일으키는 기존 수동 루프를 대체한다. 이러면 관리할 코드가 줄고 에러도 줄어든다.

###### 람다 표현식

``` js
const getName = (person) => person.name;
```

- `람다 표현식(lambda expression)(자바스크립트에서는 화살표 함수)`은 한 줄 짜리 익명 함수를 일반 함수 선언보다 단축된 구문으로 나타낸다.
- 람다 표현식은 항성 어떤값을 반화하게 만들어 함수 정의부를 확실히 함수형으로 굳힌다.
- FP는 람다 표현식과 잘 어울리는 세 주요 고계함수 map, reduce, filter를 적극 사용하는 것을 권장한다.
- 자바스크립트의 전신이자 원조 함수형 언어인 LISP의 이름도 LIst Processor(리스트 처리기)에서 비롯된 것이다.

##### _.map

``` text
# 수학적 으로 쓸 경우
map(f, [ e0, e1, e2 ...]) -> [ r0, r1, r2 ...]
```

- map은 배열 각 우너소에 이터레이터 함수를 적용하여 크기가 같은 새 배열을 반환하는 고계 함수이다.
- 루프를 쓰거나 괴팍한 스코프 문제를 신경 쓸 필요 없이 컬렉션의 원소를 전부 파싱할 경우 유용하다.
- 항상 새로운 배열을 리턴하므로 **불변성**도 간직된다.

##### _.reduce

``` text
reduce(f, [ e0, e1, e2, e3 ], accum) -> f(f(f(f(accum, e0), e1), e2), e3) -> R
```

- reduce는 원소 배열을 하나의 값으로 짜내는 고계함수로, 원소마다 함수를 실행한 결괏값의 누적치를 계산한다.
- map과 달리 reduce는 누산치에 의존하기 떄문에 결합법칙이 성립하지 않는 연산은 진행 순서(왼쪽 -> 오른쪽 OR 오른쪽 -> 왼쪽)에 따라 결과가 달라진다.
- reduce는 일괄 적용(apply-to-all)연산이라서 배열을 순회하는 도중 그만두고 나머지 원소를 생략할 방법이 없다.

##### _.filter

``` text
filter(p, [ e0, e1, e2, d3]) -> [ d0, d1 ]
```

- filter는 배열 원소를 반복하면서 술어 함수 p가 true를 반환하는 원소만 추려내고 그 결과를 새 배열에 담아 반환하는 고계 함수이다.
- 배열에서 오류 데이터를 제거하는 용도로 자주 사용된다.

##### 기타 함수

1. _.reverse()
   - 배열의 원소를 뒤집는다.
   - 원본 배열에 변이를 일으키는 함수이다.
2. _.some()
   - 배열을 순회하면서 결과가 하나라도 true면 즉시 true를 반환한다.
   - 최소 하나의 값이라도 올바른지 확인할때 유용하다.
3. _.every()
   - 배열의 모든값을 순회하면서 결과가 모두 true인지 확인한다.
   - 모든 원소가 올바른지 확인할때 유용하다.

#### 코드 헤아리기

- 함수형 흐름은 프로그램 로직을 파헤치지 않아도 무엇을 한느 프로그램인지 윤곽을 잡기 쉽기 때문에, 개발자는 코드뿐만 아니라, 결과를 내기 위해 서로 다른 단계를 드나드는 데이터의 흐름가지
  더 깊이 헤아릴 수 있다.

##### 선언적 코드와 느긋한 함수 체인

- 명령형 코드의 단점은 특정 문제의 해결만을 목표로 한다. FP보다 훨씬 저수준의에서 추상한 코드로서 한 가지로 용도가 고정된다. 추상화 수준이 낮을수록 코드를 재사용할 기회는 줄어들고 에러
  가능성과 코드 복잡성은 증가한다.
- FP는 블랙박스 컴포넌트를 서로 연결만 해주고, 뒷일은 테스트까지 만친 검증된 API에 맡겨 버린다.

``` js
// FP를 사용하면 다음처럼 코드를 직관적으로 사용할 수 있다.
_.chain(person)
  .filter(bornIn1993)
  .map(p => p.name)
  .uniq()
  .map(_.startCase())
  .sort()
  .value();
```

##### _.chain

- chain함수는 주어진 입력을 원하는 출력으로 변환하는 연산들을 연결함으로써 입력 객체의 상태를 확장시킨다.
- `_(...)` 객체로 단축 표기한 구문과 달리, 이 함수는 임의의 함수를 명시적으로 체이닝 가능한 함수로 만든다.
- 복잡한 프로그램을 느긋하게 작동시킬수 있다. 즉 실제로 사용할때 `value()`를 호출함으로서 코드가 동작하게 만드는 것이다.
- 이러한 것은 FP의 근본 원리인, 부수효과 없는 `순수함수` 덕분이다. 이를 이용하면 `무인수(point-free) 프로그래밍` 스타일로 발전 될 수 있다.

##### _.mixin

- lodash에 직접만든 함수(?)를 사용할수 있게 해준다. 예제를 보자

``` js
function vowels(string) {
  return _.filter(string, function(v) {
    return /[aeiou]/i.test(v);
  });
}
 
_.mixin({ 'vowels': vowels });
_.vowels('fred');
// => ['e']
 
_('fred').vowels().value();
// => ['e']
 
_.mixin({ 'vowels': vowels }, { 'chain': false });
_('fred').vowels();
// => ['e']

// vowels로 만든 함수를 mixin 하면 lodash chain에서 해당 함수를 사용할수 있다.
// 즉 이를 이용하면 내가 만든 함수도 chaining 할 수 있게 되는것이다. 유레카!
```
