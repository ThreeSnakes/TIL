# 디스커버리 Go 언어
## 날짜: 기억이 안난다..
## Chapter4. 함수

### 목차

- [값 넘겨주고 넘겨받기](#값-넘겨주고-넘겨받기)
  - [값 넘겨주기](#값-넘겨주기)
  - [둘 이상의 반환값](#둘-이상의-반환값)
  - [에러값 주고받기](#에러값-주고받기)
  - [명명된 결과 인자](#명명된-결과-인자)
  - [가변인자](#가변인자)
- [값으로 취급되는 함수](#값으로-취급되는-함수)
  - [함수 리터럴](#함수-리터럴)
  - [고계 함수](#고계-함수)
  - [클로저](#클로저)
  - [생성기](#생성기)
  - [명명된 자료형](#명명된-자료형)
  - [명명된 함수형](#명명된-함수형)
  - [인자 고정](#인자-고정)
  - [패턴의 추상화](#패턴의-추상화)
  - [자료구조에 담은 함수](#자료구조에-담은-함수)
- [메서드](#메서드)
  - [단순 자료형 메서드](#단순-자료형-메서드)
  - [문자열 다중 집합](#문자열-다중-집합)
  - [포인터 리시버](#포인터-리시버)
  - [공개 및 비공개](#공개-및-비공개)
- [활용](#활용)

#### 값 넘겨주고 넘겨받기

- Go에서 함수(서브루틴)은 주로 스택으로 구현되어있음
- Go에서는 값에 의한 호출(`Call By Value`)만 지원. 
  - 함수 내에서 넘겨받은 변수값을 변경 하더라도 함수 밖에의 변수는 영향을 받지 않음
  - 함수 밖의 변수 값을 변경 하려면 주소값을 넘겨 받아서 해당 주소에 값을 변경해야 함(`Call by Reference`)

##### 값 넘겨주기

- Go는 값에 의한 호출만 지원하기 때문에 깞을 넘겨주어도 함수 밖 변수는 수정되지 않음
- 수정하기 위해서는 포인터를 넘겨줘서 해당 주소의 값을 변경해야 함
- 포인터로 넘어온 값은 *을 앞에 붙여서 값을 참조할 수 있음
- 변수 앞에 &를 붙이면 해당 변수에 담겨 있는 값의 포인터 값을 얻을 수 있음
- 결국 무엇이 값인지가 중요하며, 포인터 자료형으로 받더라도 그것은 주소값이 넘어와서 받는 포인터 변수가 담게 되는거로 이해하라

##### 둘 이상의 반환값

- Go에서 함수는 둘 이상의 반환값을 리턴할 수 있음
- 반환값이 하나일 경우 괄호로 둘러쌀 필요가 없지만 둘 이상인 경우 괄호로 둘러싸야하며 반환값은 쉼표로 구별함
- 값을 받을 때에는 쉼표로 구분하여 반환값의 수에 맞게 받으면 됨

``` go
// 아래처럼 두 개 이상의 값을 리턴 할 경우 괄호를 써야 한다.
func WriteTo(w io.Writer, lines []string) (int64, error) {..}
```

##### 에러값 주고 받기

- 에러를 표시 할 수 있는 방법은 다음과 같은 방법이 존재
  - 정상적이지 않은 결과가 나올 경우 특정 값을 리턴하는 방식
  - 호출 하는 쪽에서 에러값을 받고 싶은 변수의 포인터나 레퍼런스를 함수로 넘겨 받는 방식
- Go에서는 관례적으로 에러는 가장 마지막 값으로 반환하며 이 에러를 돌려 받아서 처리하는 형식으로 작성 됨.
  - 하지만 에러를 돌려받아서 처리 할 경우 반복적인 코드가 증가됨( 항상 에러를 체크해야 하므로.. )
  - 다행히 아래와 같은 if문으로 코드를 조금이나마 줄일 수 있음

  ``` go
  // 조건문 안에서 변수를 만들고, 조건문 안에서만 해당 변수를 사용할 수 있다.
  if err := MyFunc(); err != nil {
    return nil, err
    // 위 코드는 예외를 현재 문맥에서 처리 할 수 없는 경우 호출자에게
    // 해당 에러를 그대로 반환하는 방식이다.
  }
  ```

- 새로운 에러를 생성 하는 방법은 `errors.New` 나 `fmt.Errorf`를 이용한다.
  
  ``` go
  // 1. errors.New
  return errors.New("blah blah blah")
  
  // 2. fmt.Errorf
  return fmt.Errorf("blah blah blah")
  ```

##### 명명된 결과 인자

- 돌려주는 반환값에도 이름을 붙일 수 있다.
- 돌려주는 반환값은 기본값으로 초기화 된다.
- 함수가 끝나고 return 값을 생략하면 명명된 결과 인자들의 값이 리턴된다.

``` go
// 위에 예제와 같은 방식인데 n, err 로 넘겨준다는 뜻이다.
func WriteTo(w io.Writer, lines []string) (n int64, err error) {..}
```

##### 가변인자

- 넘겨 받을 수 있는 인자의 개수가 정해져 있지 않을 경우에는 가변인자를 사용한다.

``` go
func WriteTo(w io.Writer, lines... string) (n int64, err error) {..}
```

#### 값으로 취급되는 함수

- Go에서 함수는 일급 시민으로 분류된다. 이는 함수를 변수에 담을 수 있고 다른 함수로 넘기거나 돌려 받을수 있다는 것이다.

##### 함수 리터럴

- 자바스크립트와 유사하다. 그냥 코드로 보자

``` go
// 1. 즉시 실행 함수
func(A, B) {
  return A + B
}()

// 2. 함수 리터럴
adder := func(A, B) {
  return A + B
}
```

##### 고계 함수

- 고계 함수(`higher-order function`), 함수를 넘기고 받는 다는 의미이다.
- 단순하게 생각하자. 자바스크립트처럼 함수의 인자에 함수를 넣어서 이를 활용한다 생각하면 된다.

##### 클로저

- 클로저(`closure`), 외부에서 선언한 변수를 함수 리터럴 내에서 마음대로 접근할 수 있는 코드를 말한다.
- 마찬가지로 자바스크립트로 생각하면 편하다.

##### 생성기

- 클로저를 이용한 생성기(`generator`)가 소개되어 있다.
- 그냥 코드로 생각하자.

``` go
func NewIntGenerator() func() int {
  var next int
  return func() int {
    next++
    return next
  }
}

func ExampleNewIntGenerator() {
  gen := NewIntGenerator()
  fmt.Println(gen(), gen(), gen(), gen(), gen())
  fmt.Println(gen(), gen(), gen(), gen(), gen())
  // Output:
  // 1 2 3 4 5
  // 6 7 8 9 10
}
```

##### 명명된 자료형

- 어떤 자료형을 새로운 이름으로 붙이는 것을 말한다. (EX `rune`은 `int32`의 별칭이다)

``` go
// type 예약어를 통해서 이름을 붙여줄 수 있다.
type rune int 32
```

- 자료형을 붙이면 프로그램을 직접 수행해보기 전에 컴파일 시점에서 버그를 찾을 수 있다.
- 서로다른 명명된 자료형끼리는 호환되지 않음
- 명명된 자료형을 이용하면 자료형을 하드 코드하는 것에 비하여 나중에 일괄적으로 해당 자료형의 표현을 변경할 수 있다

##### 명명된 함수형

- 함수의 자료형도 사용자가 정의 할 수 있다.
- 함수 리터럴과 명명된 함수형 사이에는 자동으로 형변환이 이루어지지만 명명된 함수형 사이에서는 형변환이 일어나지 않는다.

##### 인자 고정

- 흠 뭐라고 설명해야 하나.. 생략하자..

##### 패턴의 추상화

- 일련의 코드를 추상화하는 과정이 나와있다.
- 과도한 추상화는 코드를 보기 어렵게 하지만, 자주 사용되는 패턴의 경우 추상화를 한다면 버그를 줄이고 더 이해하기 쉽게 한다.

##### 자료구조에 담은 함수

- 자료구조에도 함수를 넣을 수 있다.
- 자바스크립트에서 오브젝에 함수 넣는거 생각하면 될것 같다.

``` go
// Map 에다가 함수를 담은 예제
opMap := map[string]BinOp{
  "+": func(a, b int) int { return a + b },
  "-": func(a, b int) int { return a - b },
  "*": func(a, b int) int { return a * b },
  "/": func(a, b int) int { return a / b },
}
```

#### 메서드

- 함수에 리시버(`receiver`)가 붙으면 메서드가 된다.
- 자료형 T에 대하여 메서드를 호출할 때 이 자료형 T에 대한 리시버가 함수 이름, 즉 메서드 이름 앞에 붙는다.
- 리시버란 개념을 잘 이해를 못하였는데.. 자료형마다 쓸수 있는 function으로 생각하자.
- Go에서는 클래스가 없는 대신 리시버 인자를 갖는 함수로 메소드를 정의 할 수 있다.
  - 잘 이해가 안되는데 아래에서 한번 참조하자.
  - [프로그래머스](https://programmers.co.kr/learn/courses/13/lessons/680)

``` go
// 아래 코드에서 (recv T) 부분이 리시버 부분이다.
func (recv T) MethodName(p1 T1, p2 T2) R1
```

##### 단순 자료형 메서드

- Go에서는 모든 명명된 자료형에서 메서드를 정의 할 수 있다.

``` go
type VertexID int
func ExampleVertexID_print() {
  i := VertexID(100)
  fmt.Println(i)
  // Output:
  // 100
}
```