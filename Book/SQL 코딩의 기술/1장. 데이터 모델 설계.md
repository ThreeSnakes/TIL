## 1장. 데이터 모델 설계

#### 1. 모든 테이블에 기본키가 있는지 확인하자.
- 관계형 모델을 따르기 위해서는 데이터베이스 시스템이 한테이블에 있는 특정 로우와 나머지 로우를  구별할 수 있어야 한다.
- 모든 테이블에는 컬러 한 개 이상으로 구성된 기본키(`Primary Key`)가 있어야 한다. 
- 기본키는 로우마다 유일해야 하며 널(`NULL`) 값을 가질 수 없다.
- 기본키가 없을 경우.
    - 반복적이고 일관성 없는 데이터가 쌓여 쿼리 수행이 느려진다.
    - 부정확한 정보를 조회할 수 있다.
    - 일반적으로 기본키가 없으면 테이블간의 관계를 모델링하는것이 불가능하다.
- 기본키에 앎맞은 후보.
    - 유일한 값을 가져야 한다. (`Unique`)
    - 널 값을 가질 수 없다.
    - 안정적인 값이어야 한다.
    - 가능한 한 간단한 형태여야 한다. ( 정수 > 문자/부동소수점, 단일키 > 복합키)
- 일반적으로 의미 없는 숫자 데이터로 자동 생성되는 컬럼을 사용 한다.
    - DB2, SQL Server, 오라클 12c => `INDETITY`
    - 액세스 => `AutoNumber`
    - MySql => `AUTO_INCREMENT`
    - PostgresSQL => `serial`
- 참조 무결성(`Reference Integrity`, `RI`)
    - RDS 모델에서 2개의 관련 있는 테이블간의 일관성을 말한다. 
    - 참조 무결성은 널이 아닌 외래키가 설정된 자식 테이블의 각 레코드와 일치하는 레코드가 부모 테이블에 존재하는 것을 의미한다.
- 텍스트 기반 컬럼을 기본키로 사용하는 이유는 중복 값 입력을 막을때 사용 한다는 의견이지만, 차라리 이 값을 유일 인덱스로 추가해 중복 되지 않게 하는 것이 더 쉽다.
- 복합 기본키(`Compound Primary Key`)는 꼭 사용해야 하는 이유가 아니라면 사용하지 않는게 좋다.
    - 컬럼 두 개 이상에 유일 인덱스를 만들면 데이터베이스 시스템에 부하가 생긴다.
    - 기본키가 여러개이면 쿼리가 더 복잡해지고, 느려진다.

#### 2. 중복으로 저장된 데이터 항목을 제거하자.
- 데이터를 중복으로 저장하면 일관되지 않은 데이터, 비정상적인 삽입/갱신/삭제 처리, 디스크 공간 낭비에 많은 문제가 생긴다.
- 정규화(`Normalization`)는 중복 데이터를 저장하면서 일으키는 문제점을 없애려고 정보를 주제(`Subject`)별로 분할 하는 프로세스를 말한다.
    - 정규화 (`Normalization`)
        - 1정규형(`1NF` = `1 Normal Foam`)
            - 중복되는 값을 제거한다. ( 도메인이 원자값으로 이루어져야 한다. )
        - 2정규형(`2NF` = `2 Normal Foam`)
            - 테이블에 존재하는 모든 함수 종속 관계가 완전 함수 종속 관계여야 한다.
            - 완전 함수 종속이란, 기본키 후보중에 특정 컬럼에만 종속된 컬럼이 없어야 한다는 것이다. 
        - 3정규형(`3NF` = `3 Normal Foam`)
            - 이행 함수적 종속 제거한다. 
            - 이행 함수적 종속이란, ( x -> y -> z )형태를 가진 테이블을 분리 한다는 것이다.
            - 키가 아닌 다른 값으로 애트리뷰트를 결정하는 릴레이션을 지우는 것을 말한다.
        - BCNF
            - 3 정규형의 강화버전이다.
            - 애트리뷰트가 후보키를 결정하는 함수적 종속성을 지우는 것이다.
            - BCNF를 만족하면 3 정규형을 만족하지만, 3정규형을 만족한다고 BCNF가 될수 있는 것은 아니다.
        - 4정규형(`4NF` = `4 Normal Foam`)
            - 다가 종속을 제거한다.
            - 다가 종속이란, 한 릴레이션에 다가 속성이 두 개 이상 존재할 때 발생한다는 것이다.
                - 하나의 A값에 대응하는 여러 개의 B 값이 있고, A 값에 대응하는 여러 개의 C 값이 있는 상태에서 B와 C가 관련이 없을 경우 다가 속성 관계이다.
                - 속성 A 하나에 속성 B가 여러 값을 결정하면 A→→B로 표시하며, A가 B를 다가결정한다라고 하고 B가 A에게 다가 종속됐다 라고 한다. 
        - 5정규형(`5NF` = `5 Normal Foam`)
            - 조인 종속을 제거한다.
            - 하나의 엔터티를 분해하고 다시 합쳤을 때 원래의 엔터티로 복원할 수 있으면 그 엔터티는 조인 종속이 존재하는 엔터티이며, 조인 종속이 존재하지 않을 때까지 분해한 엔터티이다.

#### 3. 반복 그룹을 제거하자.
- 반복그룹(비슷한 컬럼 및 데이터가 반복적으로 있어 그룹을 이루는것)을 제거 해야 한다. 
- 영향도(비용) 측면에서 컬럼은 비싸고 로우는 싸다.
    - 컬럼을 추가하거나 제거할도록 테이블을 변경해야 한다 심사 숙고 하자. 
    - 컬럼을 추가하기보다는 로우를 추가하거나 제거하도록 설계 하도록 하자.
- 반복그룹을 제거하면 인덱싱을 사용해 데이터 중복을 방지 할 수 있으며, 쿼리도 간소화된다.

#### 4. 컬럼당 하나의 특성만 저장하자.
- 테이블은 한 주제나 액션만 기술 해야 한다. 컬럼은 관계로 정의된 주제를 기술하는 유일한 특성(원자)이다. 
- 단일 컬럼에 특성 값을 두개 이상 저장하는 것은 좋지 못하다. 만약 한 컬럼에 여러 특성이 포함되어 있으면 검색이나 그루핑 작업이 가능하다고 해도 정확한 값을 뽑아내는 것은 어렵다.

#### 5. 계산데이터를 저장하면 좋지 않은지 이해하자.
- 테이블 컬럼에 계산 결과를 넣지 말자. 만약 수정이 이루어 진다면 결과 또한 다시 수정이 되야 한다. 차라리 트리거를 이용하자.
- 일부 DBMS에서는 계산 컬럼을 사용할 수도 있다. 다만 해당 컬럼은 인덱스를 타지 못하는 것을 기억하자.
    - 또한 이러한 컬럼은 참조 될때마다 해당 계산 함수를 호출 하기 때문에 상당히 성능이 떨어진다. 차라리 이러한 계산은 서버에서 하자.
- 읽다 보니깐 결론은 `그냥 계산 컬럼은 사용하지 말자`이다. 시스템 부하가 커져 성능이 느려지고 데이터의 무결성도 보장하지 못한다. 
    - 생각해보니 지금 회사의 통계를 뽑을 때 계산은 하지 않고. 각 원장 형태로 저장한 다음에 배치로 해당 데이터를 모아서 다른 테이블에 다시 저장하고 있다. 
