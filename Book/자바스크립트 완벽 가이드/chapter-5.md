자바스크립트 완벽 가이드
---

**[Chapter 5] 표현식과 연산자.**

**5.1 표현식.**
- `표현식(expression)`이란 자바스크립트 인터프리터가 계산하여 값을 구할 수 있는 자바스크립트 구절을 말한다.

**5.2 연산자 개요.**
- `C`나 `Java`랑 다를게 없다...

**5.2.1 피연산자 개수.**
- 생략..

**5.4 동등 연산자.**

**5.4.1 동등(==)과 일치(===).**
- `== 연산자`와 `=== 연산자` 모두 주어진 두 값이 같은지 확인하는데 쓰이지만, `같다`라는 것을 정의하는 기준이 서로 다르다.
- `===` 연산자는 `일치 연산자`로 알려져 있는데, `같다`라는 기준을 매우 엄격하게 정의하여 두 피연산자가 `일치(identical)`하는지 확인하다.
- `==` 연산자는 `동등 연산자`로 알려져 있으며, `같다`라는 것을 말할 때 타입 변환도 허용하는 좀 더 느슨한 정의에 입각한다.
- `할당(=)`, `동등(==)`, `일치(===)` 연산자의 차이를 확실하게 이해히야 하며, 주의해서 써야 한다.
- 자바스크립트에서 `숫자`, `문자열`, `불리언 값`들은 `값에 의해` 비교 된다. 이 경우 서로 별개인 두 값에 대해 == 연산자와 ===연산자는 이 두값이 일치하는지 확인 한다. 즉 두 변수가 똑같은 값을 가질 때에만 두 변수는 동등 내지는 일치한다고 말할수 있는 것이다.
- 반면 `객체`, `배열`, `함수`는 `참조에 의해` 비교된다. 즉 두 변수가 같은 객체를 참조할 때에만 이 두 변수는 동등하다고 말할수 있다. 예를 들면 두 배열의 값이 동등하거나 일치한다 하다라도 서로 별개인 두 배열은 절대로 동등하거나 일치 할 수 없다. 
- `=== 연산자`가 두 값이 일치하는지 아닌지를 판단 하는데에는 다음 규칙들을 따른다.
   1. 두 값의 타입이 다르다면 두 값은 일치 하지 않는다.
   2. 두 값이 모두 숫자이고 값이 같다면 두 값은 일치한다. 다만 `NaN` 값은 어느 값과도 일치 하지 않는다.(심지어 `NaN` 자체와도 일치 하지 않는다.)
   3. 두 값이 모두 문자열이고 같은 위치에 정확히 같은 문자들을 갖고 있다면 두 값은 일치 한다. 만약 문자열의 길이나 내용이 다를 경우 두 값은 일치 하지 않는다.
   4. 두 값이 모두 불리언 값 true일 경우, 또는 모두 false일 경우 두 값은 일치 한다.
   5. 두 값이 같은 객체, 배열 또는 함수를 참조할 경우 두 값은 일치한다. 설사 두 객체의 프로퍼티가 일치하거나 두 배열의 원소가 일치하더라도 서로 다른 객체라면 일치 하지 않는다.
   6. 두 값이 모두 null일 경우, 또는 두 값이 모두 undefined일 경우, 두값은 일치한다.

- `== 연산자`가 두 값이 동등한지 아닌지 판단하는 데에는 다음의 규칙을 따른다.
   1. 두 값의 타입이 같은 경우 두 값이 일치하는지 테스트 한다. 두 값이 일치할 경우 그 둘을 동등 하다. 두 값이 일치 하지 않은 경우 동등하지 않다.
   2. 두 값의 타입이 다를 경우 동등함을 확인 화는 과정에는 다음 규칙과 타입 변환이 사용된다.
   - 두 값중 하나가 null이고 다른 하나가 undefined라면 두 값은 동등하다.
   - 한 값이 숫자이고 다른 하는 문자열이면, 문자열을 숫자로 변환한 후 이를 사용해 다시 비교한다.
   - 두 값중 하나가 true이면, 이를 1로 변환한 후 다시 비교한다. 두 값중 하나가 false이면, 이를 0으로 변환 한 후 다시 비교한다.
   - 한 값이 객체이고 다른 하나는 숫자 또는 문자열이면, 객체를 기본 타입의 값으로 변환한후 다시 비교한다. 객체를 기본값으로 변환하는 데에는 해당 객체의 `toString()`메서드나 `valueOf()`메서드를 사용한다.
   - 위에 열거하지 않은 기타 값들의 조항은 동등하지 않는다.

**5.4.2 부등(!=)과 불일치(!==)**
- `!= 연산자`와 `!== 연산자`가 테스트 하는 것은 `==` 및 `===`연산자가 테스트 하는 것과 정확히 반대다.

**5.5.2 in 연산자.**
- `in 연산자`는 좌변의 피연산자로 문자열(또는 문자열로 반환되는것)을 받는다. 우변의 피연산자로는 객체나 배열을 받는다. 
- 좌변 값이 우변 객체의 프로퍼티 이름에 해당할 경우 연산자는 true다.

```JS
var point = {x:1, y:2};
var has_x_coord = "x" in point; // true
var has_y_coord = "y" in point; // true
var hss_z_coord = "z" in point; // false
var ts = "toString" in point; // 상속된 프로퍼티, true
```

**5.5.3 instanceof 연산자**
- `instanceof` 연산자는 좌벼니의 피연산자로 객체를, 우변의 피연산자로 객체 클래스의 이름을 받는다.
- 좌변 객체가 우변 클래의 인스턴스일 경우 연산 결과는 true이고 그렇지 않을 경우 false다.

```JS
var d = new Date();
d instanceof Date;	// true. d는 Date()에 의해 생성되었다.
d instanceof Object; // true. 모든 객체는 Object의 인스턴스
d instanceof Number; // false. d는 Number 객체가 아니다.
```
- 모든 객체는 Object의 인스터스임을 기억하자.
- 만일 `instanceof`의 좌변 피연산자가 객체가 아니거나 우변 피연산자가 어떤 생성자 함수에도 해당되지 않는 객체라면 instanceof의 결과는 false다.
- 우변 연산자가 아예 객체가 아닐 경우에는 런타임 에러가 발생한다.

**5.10.1 조건부 연산자(?:)**
- 조건부 연산자는 자바스크립트의 유이리한 3항 연산자(피연사자가 세개)이며, 때로는 그 자체로 3항 연산자라고 불리기도 한다.

```JS
x > 0 ? x*y : -x*y
```

- 조건부 연산자의 첫 번쨰 피연산자는 불리언 값이어야 한다. 그 값이 true이면 두번째 피연산자의 값을 리턴하고, false일 경우 세 번째 피연산자가 값을 리턴한다.

**5.10.2 typeof 연산자.**
- `typeof`연산자는 단일 피연산자 앞에 위치하는 단항 연산자로, 피연산자는 아무 타입이 와도 된다.
-  주어진 피연산자가 숫자, 문자열, 또는 불리언 값일 경우 typeof의 연산자의 결과는 그에 따라 `"number"`, `"string"`, `"bollean"`이 된다. 
-  객체, 배열, null에 대해서는 `"object"`를 반환한다.
-  함수에 대해서는 `"function"`을 리턴한다.
-  정의되지 않은 피연산자에 대해서는 `"undefined"`를 반환한다.

**5.10.3 객체 생성 연산자(new)**
- `new`연산자는 새로운 객체를 생성하고 이를 초기화하기 위한 생성자 함수를 호출한다.

**5.10.4 delete 연산자.**
- delete는 단항 연사자이며, 피연산자로 지정된 객체 프로퍼티, 배열 원소 또는 변수의 삭제를 시도한다.
- 피연산자가 성공적으로 삭제되었을 경우 true를 반환하고, 삭제될 수 없는 경우 false를 반환한다.
- 사용자가 var문으로 정의한 변수는 삭제할수 없고, 존재하지 않는 프로퍼티에 대해 delete를 호출할 경우 true가 반환된다.
- `delete`가 영향을 미치는 것은 오직 프로퍼티 뿐이며 해당 프로퍼티가 참조하고 있던 객체는 무관하다.

```JS
var my = new Object();
my.hire = new Date();
my.fire = my.hire;
delete my.hire;           // hire가 삭제되고 true가 반환될 것이다.
document.write(my.fire);  // 하지만 my.fire는 여전히 Date객체를 참조하고 있다.
```

**5.10.5 void 연산자.**
- `void`는 단일 피연산자 앞에 쓰이는 단항 연산자로, 피연사자의 타입은 아무 타입이라도 관계없다.
- `void`연산자는 피연산자의 값을 무시하고 `undefined`를 반환한다.
- `void`연산자는 의도적으로 `undefined` 값을 만들어내기 위해서 사용된다.